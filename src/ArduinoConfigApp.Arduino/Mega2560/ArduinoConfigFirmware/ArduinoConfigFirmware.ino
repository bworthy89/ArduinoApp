/*
 * Arduino Configuration Firmware for Mega 2560
 * This firmware communicates with the desktop app via serial
 * and handles inputs and displays
 *
 * NOTE: Mega 2560 does NOT support native USB HID keyboard output
 * Use Arduino Pro Micro if you need keyboard emulation
 *
 * Required Libraries:
 * - ArduinoJson (v6.x): https://github.com/bblanchon/ArduinoJson
 * - LedControl: https://github.com/wayoda/LedControl
 * - Encoder: https://github.com/PaulStoffregen/Encoder
 */

#include <ArduinoJson.h>

// Uncomment if using displays
// #include <LedControl.h>

// Uncomment if using encoders
// #include <Encoder.h>

// ===== CONFIGURATION =====
// These values are generated by the desktop app

#define FIRMWARE_VERSION "1.0.0"
#define SERIAL_BAUD 115200
#define MAX_INPUTS 32  // Mega 2560 has more pins than Pro Micro
#define MAX_DISPLAYS 8
#define DEBOUNCE_MS 50
#define POLL_INTERVAL_MS 50

// ===== PIN DEFINITIONS =====
// (Generated by desktop app)

// Example: Button on pin 2
// #define INPUT_0_PIN 2

// Example: Encoder on pins 3, 4
// #define INPUT_1_PIN_A 3
// #define INPUT_1_PIN_B 4

// Example: Display CS pin
// #define DISPLAY_DIN 51  // MOSI
// #define DISPLAY_CLK 52  // SCK
// #define DISPLAY_0_CS 10

// ===== GLOBAL STATE =====

// Input states
bool inputStates[MAX_INPUTS] = {0};
bool lastInputStates[MAX_INPUTS] = {0};
unsigned long lastDebounce[MAX_INPUTS] = {0};
int inputCount = 0;

// Encoder values (if using encoders)
// long encoderValues[MAX_INPUTS] = {0};

// Display values (if using displays)
// long displayValues[MAX_DISPLAYS] = {0};
// int displayCount = 0;

// Operating mode
bool testMode = false;        // When true, disables any output actions

// Timing
unsigned long lastPollTime = 0;

// Serial buffer
StaticJsonDocument<512> jsonDoc;
String inputBuffer = "";

// ===== SETUP =====

void setup() {
  // Initialize serial
  Serial.begin(SERIAL_BAUD);
  while (!Serial) {
    delay(10);
  }

  // NOTE: Mega 2560 does NOT support native USB HID keyboard
  // Keyboard output must be handled by the desktop application

  // === Configure input pins ===
  // (Generated code goes here)
  // Example:
  // pinMode(INPUT_0_PIN, INPUT_PULLUP);

  // === Initialize displays ===
  // (Generated code goes here)
  // Example:
  // display_0.shutdown(0, false);
  // display_0.setIntensity(0, 8);
  // display_0.clearDisplay(0);

  // === Initialize encoders ===
  // (Generated code goes here)
  // Encoder library handles pin modes

  // Send ready signal
  Serial.println("{\"response\":\"READY\",\"version\":\"" FIRMWARE_VERSION "\"}");
}

// ===== MAIN LOOP =====

void loop() {
  // Process incoming serial commands
  processSerial();

  // Poll inputs at fixed interval
  if (millis() - lastPollTime >= POLL_INTERVAL_MS) {
    readInputs();
    handleInputChanges();
    updateDisplays();
    lastPollTime = millis();
  }
}

// ===== SERIAL PROTOCOL =====

void processSerial() {
  while (Serial.available()) {
    char c = Serial.read();

    if (c == '\n') {
      processCommand(inputBuffer);
      inputBuffer = "";
    } else if (c != '\r') {
      inputBuffer += c;
    }
  }
}

void processCommand(String& input) {
  if (input.length() == 0) return;

  DeserializationError error = deserializeJson(jsonDoc, input);

  if (error) {
    sendError("JSON parse error");
    return;
  }

  const char* cmd = jsonDoc["cmd"];
  if (!cmd) {
    sendError("Missing cmd");
    return;
  }

  // Handle commands
  if (strcmp(cmd, "PING") == 0) {
    Serial.println("{\"response\":\"PONG\",\"success\":true}");
  }
  else if (strcmp(cmd, "VERSION") == 0) {
    Serial.print("{\"response\":\"VERSION\",\"success\":true,\"data\":\"");
    Serial.print(FIRMWARE_VERSION);
    Serial.println("\"}");
  }
  else if (strcmp(cmd, "GET_STATE") == 0) {
    sendStateUpdate();
  }
  else if (strcmp(cmd, "TEST_MODE") == 0) {
    testMode = jsonDoc["params"]["enabled"] | false;
    sendOk();
  }
  else if (strcmp(cmd, "SET_DISPLAY") == 0) {
    int idx = jsonDoc["params"]["display"] | 0;
    long val = jsonDoc["params"]["value"] | 0;
    setDisplayValue(idx, val);
    sendOk();
  }
  else if (strcmp(cmd, "TEST_DISPLAY") == 0) {
    int idx = jsonDoc["params"]["display"] | 0;
    testDisplay(idx);
    sendOk();
  }
  else {
    sendError("Unknown command");
  }
}

void sendOk() {
  Serial.println("{\"response\":\"OK\",\"success\":true}");
}

void sendError(const char* msg) {
  Serial.print("{\"response\":\"ERROR\",\"success\":false,\"message\":\"");
  Serial.print(msg);
  Serial.println("\"}");
}

void sendStateUpdate() {
  Serial.print("{\"response\":\"STATE\",\"success\":true,\"inputs\":[");

  for (int i = 0; i < inputCount; i++) {
    if (i > 0) Serial.print(",");
    Serial.print("{\"id\":");
    Serial.print(i);
    Serial.print(",\"state\":");
    Serial.print(inputStates[i] ? 1 : 0);
    // Add encoder value if applicable
    // Serial.print(",\"value\":");
    // Serial.print(encoderValues[i]);
    Serial.print("}");
  }

  Serial.println("]}");
}

void sendInputEvent(int inputIdx, const char* eventType, int value = 0) {
  Serial.print("{\"response\":\"INPUT_EVENT\",\"type\":\"");
  Serial.print(eventType);
  Serial.print("\",\"id\":");
  Serial.print(inputIdx);
  if (value != 0) {
    Serial.print(",\"value\":");
    Serial.print(value);
  }
  Serial.println("}");
}

// ===== INPUT HANDLING =====

void readInputs() {
  // === Read button/switch inputs ===
  // (Generated code goes here)
  // Example:
  // readButton(0, INPUT_0_PIN);

  // === Read encoder inputs ===
  // (Generated code goes here)
  // Example:
  // readEncoder(1);
}

void readButton(int idx, int pin) {
  bool reading = !digitalRead(pin);  // Active LOW with pullup

  if (reading != lastInputStates[idx]) {
    lastDebounce[idx] = millis();
  }

  if ((millis() - lastDebounce[idx]) > DEBOUNCE_MS) {
    if (reading != inputStates[idx]) {
      inputStates[idx] = reading;
      sendInputEvent(idx, reading ? "BTN_PRESS" : "BTN_RELEASE");
    }
  }

  lastInputStates[idx] = reading;
}

// Example encoder reading (requires Encoder library)
/*
void readEncoder(int idx) {
  long newValue = encoder_X.read() / 4;  // 4 steps per detent

  if (newValue != lastEncoderValue_X) {
    int direction = newValue > lastEncoderValue_X ? 1 : -1;
    encoderValues[idx] += direction;
    lastEncoderValue_X = newValue;

    sendInputEvent(idx, direction > 0 ? "ENC_CW" : "ENC_CCW", encoderValues[idx]);
  }
}
*/

// ===== INPUT CHANGE HANDLING =====

void handleInputChanges() {
  // NOTE: Mega 2560 does not support native USB HID keyboard output
  // Input events are sent to the desktop app via serial protocol
  // The desktop app handles keyboard output using Windows API

  // If you need keyboard output, use Arduino Pro Micro instead

  // Custom actions can be implemented here (e.g., trigger relays, LEDs, etc.)
}

// ===== DISPLAY CONTROL =====

void updateDisplays() {
  // === Update all displays with current values ===
  // (Generated code goes here)
  // Example:
  // displayNumber(display_0, displayValues[0], 8, false);
}

void setDisplayValue(int idx, long value) {
  // Set display value
  // (Generated code goes here)
  // Example:
  // if (idx == 0) displayValues[0] = value;
}

void testDisplay(int idx) {
  // Show test pattern on display
  // (Generated code goes here)
  // Example: Show all 8s
  // for (int d = 0; d < 8; d++) {
  //   display_0.setDigit(0, d, 8, false);
  // }
}

// Display number on MAX7219
// (Utility function - used by generated code)
/*
void displayNumber(LedControl& lc, long value, int digits, bool leadingZeros) {
  bool negative = value < 0;
  if (negative) value = -value;

  for (int i = 0; i < digits; i++) {
    int digit = value % 10;
    value /= 10;

    if (value == 0 && digit == 0 && !leadingZeros && i > 0) {
      if (negative && i == digits - 1) {
        lc.setChar(0, i, '-', false);
      } else {
        lc.setChar(0, i, ' ', false);
      }
    } else {
      lc.setDigit(0, i, digit, false);
    }
  }
}
*/
