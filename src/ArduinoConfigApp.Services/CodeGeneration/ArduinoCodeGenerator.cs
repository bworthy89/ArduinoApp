using System.Text;
using ArduinoConfigApp.Core.Enums;
using ArduinoConfigApp.Core.Interfaces;
using ArduinoConfigApp.Core.Models;

namespace ArduinoConfigApp.Services.CodeGeneration;

/// <summary>
/// Generates Arduino sketches from project configuration
/// Creates complete, compilable code for Pro Micro and Mega 2560
/// </summary>
public class ArduinoCodeGenerator : ICodeGenerationService
{
    public GeneratedCode GenerateSketch(ProjectConfiguration configuration)
    {
        var code = new GeneratedCode
        {
            SketchName = SanitizeSketchName(configuration.Name),
            RequiredLibraries = GetRequiredLibraries(configuration).ToList()
        };

        var sb = new StringBuilder();

        // Header comment
        sb.AppendLine("/*");
        sb.AppendLine($" * {configuration.Name}");
        sb.AppendLine($" * Generated by Arduino Config App");
        sb.AppendLine($" * Date: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        sb.AppendLine($" * Board: {configuration.TargetBoard}");
        sb.AppendLine(" */");
        sb.AppendLine();

        // Include statements
        sb.AppendLine(GenerateIncludes(configuration));
        sb.AppendLine();

        // Pin definitions
        sb.AppendLine(GeneratePinDefinitions(configuration));
        sb.AppendLine();

        // Global variables
        sb.AppendLine(GenerateGlobalVariables(configuration));
        sb.AppendLine();

        // Setup function
        sb.AppendLine("void setup() {");
        sb.AppendLine(Indent(GeneratePinSetup(configuration)));
        sb.AppendLine("}");
        sb.AppendLine();

        // Loop function
        sb.AppendLine("void loop() {");
        sb.AppendLine(Indent(GenerateLoopBody(configuration)));
        sb.AppendLine("}");
        sb.AppendLine();

        // Helper functions
        sb.AppendLine(GenerateInputHandling(configuration));
        sb.AppendLine();
        sb.AppendLine(GenerateDisplayControl(configuration));
        sb.AppendLine();
        sb.AppendLine(GenerateKeyboardOutput(configuration));
        sb.AppendLine();
        sb.AppendLine(GenerateSerialProtocol(configuration));

        code.MainSketch = sb.ToString();
        return code;
    }

    private string GenerateIncludes(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        // Serial communication
        sb.AppendLine("#include <ArduinoJson.h>");

        // Display library
        if (config.Displays.Count > 0)
        {
            sb.AppendLine("#include <LedControl.h>");
        }

        // Keyboard library (Pro Micro only)
        if (config.TargetBoard == BoardType.ProMicro)
        {
            sb.AppendLine("#include <Keyboard.h>");
        }

        // Encoder library
        if (config.Inputs.Any(i => i is EncoderConfiguration))
        {
            sb.AppendLine("#include <Encoder.h>");
        }

        return sb.ToString();
    }

    private string GeneratePinDefinitions(ProjectConfiguration config)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// Pin Definitions");

        // Input pins
        for (int i = 0; i < config.Inputs.Count; i++)
        {
            var input = config.Inputs[i];
            var prefix = $"INPUT_{i}";

            switch (input)
            {
                case ButtonConfiguration btn:
                    sb.AppendLine($"#define {prefix}_PIN {btn.Pin}  // {input.Name}");
                    break;

                case EncoderConfiguration enc:
                    sb.AppendLine($"#define {prefix}_PIN_A {enc.PinA}  // {input.Name} CLK");
                    sb.AppendLine($"#define {prefix}_PIN_B {enc.PinB}  // {input.Name} DT");
                    if (enc.ButtonPin >= 0)
                    {
                        sb.AppendLine($"#define {prefix}_BTN_PIN {enc.ButtonPin}  // {input.Name} SW");
                    }
                    break;

                case ToggleSwitchConfiguration tog:
                    sb.AppendLine($"#define {prefix}_PIN {tog.Pin}  // {input.Name}");
                    break;
            }
        }

        // Display pins (SPI)
        if (config.Displays.Count > 0)
        {
            var board = new ArduinoBoard { BoardType = config.TargetBoard };
            sb.AppendLine();
            sb.AppendLine("// Display SPI Pins");
            sb.AppendLine($"#define DISPLAY_DIN {board.SpiPins.Mosi}  // MOSI");
            sb.AppendLine($"#define DISPLAY_CLK {board.SpiPins.Sck}   // SCK");

            for (int i = 0; i < config.Displays.Count; i++)
            {
                var display = config.Displays[i];
                sb.AppendLine($"#define DISPLAY_{i}_CS {display.CsPin}  // {display.Name} CS");
            }
        }

        return sb.ToString();
    }

    private string GenerateGlobalVariables(ProjectConfiguration config)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// Global Variables");
        sb.AppendLine("const unsigned long DEBOUNCE_MS = 50;");
        sb.AppendLine("const unsigned long SERIAL_INTERVAL_MS = 50;");
        sb.AppendLine("unsigned long lastSerialUpdate = 0;");
        sb.AppendLine("bool testMode = false;");
        sb.AppendLine();

        // Input state arrays
        sb.AppendLine($"// Input states ({config.Inputs.Count} inputs)");
        sb.AppendLine($"bool inputStates[{config.Inputs.Count}] = {{0}};");
        sb.AppendLine($"bool lastInputStates[{config.Inputs.Count}] = {{0}};");
        sb.AppendLine($"unsigned long lastDebounce[{config.Inputs.Count}] = {{0}};");
        sb.AppendLine();

        // Encoder objects and values
        var encoders = config.Inputs.OfType<EncoderConfiguration>().ToList();
        if (encoders.Count > 0)
        {
            sb.AppendLine("// Encoder objects");
            for (int i = 0; i < config.Inputs.Count; i++)
            {
                if (config.Inputs[i] is EncoderConfiguration enc)
                {
                    sb.AppendLine($"Encoder encoder_{i}(INPUT_{i}_PIN_A, INPUT_{i}_PIN_B);");
                    sb.AppendLine($"long encoderValue_{i} = {enc.CurrentValue};");
                    sb.AppendLine($"long lastEncoderValue_{i} = {enc.CurrentValue};");
                }
            }
            sb.AppendLine();
        }

        // Display objects
        if (config.Displays.Count > 0)
        {
            sb.AppendLine("// Display objects (LedControl: DIN, CLK, CS, numDevices)");
            for (int i = 0; i < config.Displays.Count; i++)
            {
                var display = config.Displays[i];
                sb.AppendLine($"LedControl display_{i} = LedControl(DISPLAY_DIN, DISPLAY_CLK, DISPLAY_{i}_CS, {display.ChainedDevices});");
                sb.AppendLine($"long displayValue_{i} = 0;");
            }
            sb.AppendLine();
        }

        // JSON document for serial communication
        sb.AppendLine("// Serial communication buffer");
        sb.AppendLine("StaticJsonDocument<512> jsonDoc;");

        return sb.ToString();
    }

    public string GeneratePinSetup(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Initialize serial communication");
        sb.AppendLine("Serial.begin(115200);");
        sb.AppendLine("while (!Serial) { delay(10); }");
        sb.AppendLine();

        // Initialize keyboard (Pro Micro)
        if (config.TargetBoard == BoardType.ProMicro)
        {
            sb.AppendLine("// Initialize keyboard HID");
            sb.AppendLine("Keyboard.begin();");
            sb.AppendLine();
        }

        // Configure input pins
        sb.AppendLine("// Configure input pins");
        for (int i = 0; i < config.Inputs.Count; i++)
        {
            var input = config.Inputs[i];
            var pullup = input switch
            {
                ButtonConfiguration btn => btn.UseInternalPullup,
                EncoderConfiguration enc => enc.UseInternalPullups,
                ToggleSwitchConfiguration tog => tog.UseInternalPullup,
                _ => true
            };

            var mode = pullup ? "INPUT_PULLUP" : "INPUT";

            switch (input)
            {
                case ButtonConfiguration:
                    sb.AppendLine($"pinMode(INPUT_{i}_PIN, {mode});");
                    break;

                case EncoderConfiguration enc:
                    // Encoder library handles pin modes
                    if (enc.ButtonPin >= 0)
                    {
                        sb.AppendLine($"pinMode(INPUT_{i}_BTN_PIN, {mode});");
                    }
                    break;

                case ToggleSwitchConfiguration:
                    sb.AppendLine($"pinMode(INPUT_{i}_PIN, {mode});");
                    break;
            }
        }
        sb.AppendLine();

        // Initialize displays
        if (config.Displays.Count > 0)
        {
            sb.AppendLine("// Initialize MAX7219 displays");
            for (int i = 0; i < config.Displays.Count; i++)
            {
                var display = config.Displays[i];
                sb.AppendLine($"display_{i}.shutdown(0, false);");
                sb.AppendLine($"display_{i}.setIntensity(0, {display.Brightness});");
                sb.AppendLine($"display_{i}.clearDisplay(0);");
            }
        }

        return sb.ToString();
    }

    private string GenerateLoopBody(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Process serial commands");
        sb.AppendLine("processSerial();");
        sb.AppendLine();

        sb.AppendLine("// Read all inputs");
        sb.AppendLine("readInputs();");
        sb.AppendLine();

        sb.AppendLine("// Handle input changes");
        sb.AppendLine("handleInputChanges();");
        sb.AppendLine();

        sb.AppendLine("// Update displays");
        sb.AppendLine("updateDisplays();");
        sb.AppendLine();

        sb.AppendLine("// Send state updates periodically");
        sb.AppendLine("if (millis() - lastSerialUpdate >= SERIAL_INTERVAL_MS) {");
        sb.AppendLine("  sendStateUpdate();");
        sb.AppendLine("  lastSerialUpdate = millis();");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public string GenerateInputHandling(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Read all inputs with debouncing");
        sb.AppendLine("void readInputs() {");

        for (int i = 0; i < config.Inputs.Count; i++)
        {
            var input = config.Inputs[i];
            var debounceMs = input switch
            {
                ButtonConfiguration btn => btn.DebounceMs,
                ToggleSwitchConfiguration tog => tog.DebounceMs,
                _ => 50
            };

            switch (input)
            {
                case ButtonConfiguration:
                case ToggleSwitchConfiguration:
                    sb.AppendLine($"  // {input.Name}");
                    sb.AppendLine($"  bool reading_{i} = !digitalRead(INPUT_{i}_PIN);  // Active LOW");
                    sb.AppendLine($"  if (reading_{i} != lastInputStates[{i}]) {{");
                    sb.AppendLine($"    lastDebounce[{i}] = millis();");
                    sb.AppendLine($"  }}");
                    sb.AppendLine($"  if ((millis() - lastDebounce[{i}]) > {debounceMs}) {{");
                    sb.AppendLine($"    inputStates[{i}] = reading_{i};");
                    sb.AppendLine($"  }}");
                    sb.AppendLine($"  lastInputStates[{i}] = reading_{i};");
                    sb.AppendLine();
                    break;

                case EncoderConfiguration enc:
                    sb.AppendLine($"  // {input.Name} (encoder)");
                    sb.AppendLine($"  long newEncoderVal_{i} = encoder_{i}.read() / {enc.StepsPerDetent};");
                    sb.AppendLine($"  if (newEncoderVal_{i} != lastEncoderValue_{i}) {{");
                    sb.AppendLine($"    int direction = newEncoderVal_{i} > lastEncoderValue_{i} ? 1 : -1;");
                    sb.AppendLine($"    encoderValue_{i} += direction * {(int)enc.Increment};");
                    sb.AppendLine($"    encoderValue_{i} = constrain(encoderValue_{i}, {enc.MinValue}, {enc.MaxValue});");
                    sb.AppendLine($"    lastEncoderValue_{i} = newEncoderVal_{i};");

                    if (enc.LinkedDisplayId.HasValue)
                    {
                        var displayIndex = config.Displays.FindIndex(d => d.Id == enc.LinkedDisplayId);
                        if (displayIndex >= 0)
                        {
                            sb.AppendLine($"    displayValue_{displayIndex} = encoderValue_{i};");
                        }
                    }

                    sb.AppendLine($"    sendEncoderEvent({i}, direction);");
                    sb.AppendLine($"  }}");
                    if (enc.ButtonPin >= 0)
                    {
                        sb.AppendLine($"  inputStates[{i}] = !digitalRead(INPUT_{i}_BTN_PIN);");
                    }
                    sb.AppendLine();
                    break;
            }
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    public string GenerateDisplayControl(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        if (config.Displays.Count == 0)
        {
            sb.AppendLine("// No displays configured");
            sb.AppendLine("void updateDisplays() { }");
            return sb.ToString();
        }

        sb.AppendLine("// Update all MAX7219 displays");
        sb.AppendLine("void updateDisplays() {");

        for (int i = 0; i < config.Displays.Count; i++)
        {
            var display = config.Displays[i];
            sb.AppendLine($"  displayNumber(display_{i}, displayValue_{i}, {display.DigitCount}, {display.ShowLeadingZeros.ToString().ToLower()});");
        }

        sb.AppendLine("}");
        sb.AppendLine();

        // Helper function to display a number on MAX7219
        sb.AppendLine("// Display a number on MAX7219");
        sb.AppendLine("void displayNumber(LedControl& lc, long value, int digits, bool leadingZeros) {");
        sb.AppendLine("  bool negative = value < 0;");
        sb.AppendLine("  if (negative) value = -value;");
        sb.AppendLine("  ");
        sb.AppendLine("  for (int i = 0; i < digits; i++) {");
        sb.AppendLine("    int digit = value % 10;");
        sb.AppendLine("    value /= 10;");
        sb.AppendLine("    ");
        sb.AppendLine("    if (value == 0 && digit == 0 && !leadingZeros && i > 0) {");
        sb.AppendLine("      if (negative && i == digits - 1) {");
        sb.AppendLine("        lc.setChar(0, i, '-', false);");
        sb.AppendLine("      } else {");
        sb.AppendLine("        lc.setChar(0, i, ' ', false);");
        sb.AppendLine("      }");
        sb.AppendLine("    } else {");
        sb.AppendLine("      lc.setDigit(0, i, digit, false);");
        sb.AppendLine("    }");
        sb.AppendLine("  }");
        sb.AppendLine("}");
        sb.AppendLine();

        // Test pattern function
        sb.AppendLine("// Display test pattern");
        sb.AppendLine("void testDisplayPattern(int displayIdx, const char* pattern) {");
        sb.AppendLine("  // Simplified test - just show 88888888");
        for (int i = 0; i < config.Displays.Count; i++)
        {
            sb.AppendLine($"  if (displayIdx == {i}) {{");
            sb.AppendLine($"    for (int d = 0; d < 8; d++) display_{i}.setDigit(0, d, 8, false);");
            sb.AppendLine($"  }}");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    public string GenerateKeyboardOutput(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        if (config.TargetBoard != BoardType.ProMicro)
        {
            sb.AppendLine("// Keyboard output not available on this board");
            sb.AppendLine("void handleInputChanges() {");
            sb.AppendLine("  // No keyboard support on Mega 2560");
            sb.AppendLine("}");
            return sb.ToString();
        }

        sb.AppendLine("// Handle input changes and send keyboard outputs");
        sb.AppendLine("void handleInputChanges() {");
        sb.AppendLine("  static bool prevStates[" + config.Inputs.Count + "] = {0};");
        sb.AppendLine();
        sb.AppendLine("  if (testMode) return;  // Skip keyboard output in test mode");
        sb.AppendLine();

        for (int i = 0; i < config.Inputs.Count; i++)
        {
            var input = config.Inputs[i];
            var mappings = config.KeyboardMappings.Where(m => m.InputId == input.Id && m.IsEnabled).ToList();

            if (mappings.Count == 0)
                continue;

            sb.AppendLine($"  // {input.Name}");

            foreach (var mapping in mappings)
            {
                var keyCode = GetArduinoKeyCode(mapping.Key);
                var modifiers = GetArduinoModifiers(mapping.Modifiers);

                switch (mapping.TriggerAction)
                {
                    case InputAction.Press:
                        sb.AppendLine($"  if (inputStates[{i}] && !prevStates[{i}]) {{");
                        if (!string.IsNullOrEmpty(modifiers))
                            sb.AppendLine($"    {modifiers}");
                        sb.AppendLine($"    Keyboard.press({keyCode});");
                        sb.AppendLine($"    Keyboard.release({keyCode});");
                        if (!string.IsNullOrEmpty(modifiers))
                            sb.AppendLine($"    Keyboard.releaseAll();");
                        sb.AppendLine($"  }}");
                        break;

                    case InputAction.Release:
                        sb.AppendLine($"  if (!inputStates[{i}] && prevStates[{i}]) {{");
                        sb.AppendLine($"    Keyboard.press({keyCode});");
                        sb.AppendLine($"    Keyboard.release({keyCode});");
                        sb.AppendLine($"  }}");
                        break;

                    case InputAction.ToggleOn:
                    case InputAction.ToggleOff:
                        var onOff = mapping.TriggerAction == InputAction.ToggleOn;
                        sb.AppendLine($"  if (inputStates[{i}] == {onOff.ToString().ToLower()} && inputStates[{i}] != prevStates[{i}]) {{");
                        sb.AppendLine($"    Keyboard.press({keyCode});");
                        sb.AppendLine($"    Keyboard.release({keyCode});");
                        sb.AppendLine($"  }}");
                        break;
                }
            }

            sb.AppendLine($"  prevStates[{i}] = inputStates[{i}];");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private string GenerateSerialProtocol(ProjectConfiguration config)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// Serial protocol handling");
        sb.AppendLine("void processSerial() {");
        sb.AppendLine("  if (!Serial.available()) return;");
        sb.AppendLine();
        sb.AppendLine("  String input = Serial.readStringUntil('\\n');");
        sb.AppendLine("  input.trim();");
        sb.AppendLine("  if (input.length() == 0) return;");
        sb.AppendLine();
        sb.AppendLine("  DeserializationError error = deserializeJson(jsonDoc, input);");
        sb.AppendLine("  if (error) {");
        sb.AppendLine("    sendError(\"JSON parse error\");");
        sb.AppendLine("    return;");
        sb.AppendLine("  }");
        sb.AppendLine();
        sb.AppendLine("  const char* cmd = jsonDoc[\"cmd\"];");
        sb.AppendLine("  if (!cmd) {");
        sb.AppendLine("    sendError(\"Missing cmd\");");
        sb.AppendLine("    return;");
        sb.AppendLine("  }");
        sb.AppendLine();
        sb.AppendLine("  if (strcmp(cmd, \"PING\") == 0) {");
        sb.AppendLine("    Serial.println(\"{\\\"response\\\":\\\"PONG\\\",\\\"success\\\":true}\");");
        sb.AppendLine("  }");
        sb.AppendLine("  else if (strcmp(cmd, \"VERSION\") == 0) {");
        sb.AppendLine("    Serial.println(\"{\\\"response\\\":\\\"VERSION\\\",\\\"success\\\":true,\\\"data\\\":\\\"1.0.0\\\"}\");");
        sb.AppendLine("  }");
        sb.AppendLine("  else if (strcmp(cmd, \"GET_STATE\") == 0) {");
        sb.AppendLine("    sendStateUpdate();");
        sb.AppendLine("  }");
        sb.AppendLine("  else if (strcmp(cmd, \"TEST_MODE\") == 0) {");
        sb.AppendLine("    testMode = jsonDoc[\"params\"][\"enabled\"] | false;");
        sb.AppendLine("    Serial.println(\"{\\\"response\\\":\\\"OK\\\",\\\"success\\\":true}\");");
        sb.AppendLine("  }");
        sb.AppendLine("  else if (strcmp(cmd, \"SET_DISPLAY\") == 0) {");
        sb.AppendLine("    int idx = jsonDoc[\"params\"][\"display\"] | 0;");
        sb.AppendLine("    long val = jsonDoc[\"params\"][\"value\"] | 0;");
        sb.AppendLine("    setDisplayValue(idx, val);");
        sb.AppendLine("    Serial.println(\"{\\\"response\\\":\\\"OK\\\",\\\"success\\\":true}\");");
        sb.AppendLine("  }");
        sb.AppendLine("  else if (strcmp(cmd, \"TEST_DISPLAY\") == 0) {");
        sb.AppendLine("    int idx = jsonDoc[\"params\"][\"display\"] | 0;");
        sb.AppendLine("    const char* pattern = jsonDoc[\"params\"][\"pattern\"] | \"ALL_ON\";");
        sb.AppendLine("    testDisplayPattern(idx, pattern);");
        sb.AppendLine("    Serial.println(\"{\\\"response\\\":\\\"OK\\\",\\\"success\\\":true}\");");
        sb.AppendLine("  }");
        sb.AppendLine("  else {");
        sb.AppendLine("    sendError(\"Unknown command\");");
        sb.AppendLine("  }");
        sb.AppendLine("}");
        sb.AppendLine();

        // Helper functions
        sb.AppendLine("void sendError(const char* msg) {");
        sb.AppendLine("  Serial.print(\"{\\\"response\\\":\\\"ERROR\\\",\\\"success\\\":false,\\\"message\\\":\\\"\");");
        sb.AppendLine("  Serial.print(msg);");
        sb.AppendLine("  Serial.println(\"\\\"}\");");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("void sendStateUpdate() {");
        sb.AppendLine("  Serial.print(\"{\\\"response\\\":\\\"STATE\\\",\\\"success\\\":true,\\\"inputs\\\":[\");");
        for (int i = 0; i < config.Inputs.Count; i++)
        {
            var input = config.Inputs[i];
            if (i > 0) sb.AppendLine("  Serial.print(\",\");");

            if (input is EncoderConfiguration)
            {
                sb.AppendLine($"  Serial.print(\"{{\\\"id\\\":{i},\\\"state\\\":\");");
                sb.AppendLine($"  Serial.print(inputStates[{i}] ? 1 : 0);");
                sb.AppendLine($"  Serial.print(\",\\\"value\\\":\");");
                sb.AppendLine($"  Serial.print(encoderValue_{i});");
                sb.AppendLine($"  Serial.print(\"}}\");");
            }
            else
            {
                sb.AppendLine($"  Serial.print(\"{{\\\"id\\\":{i},\\\"state\\\":\");");
                sb.AppendLine($"  Serial.print(inputStates[{i}] ? 1 : 0);");
                sb.AppendLine($"  Serial.print(\"}}\");");
            }
        }
        sb.AppendLine("  Serial.println(\"]}\");");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("void sendEncoderEvent(int idx, int direction) {");
        sb.AppendLine("  Serial.print(\"{\\\"response\\\":\\\"INPUT_EVENT\\\",\\\"type\\\":\\\"\");");
        sb.AppendLine("  Serial.print(direction > 0 ? \"ENC_CW\" : \"ENC_CCW\");");
        sb.AppendLine("  Serial.print(\"\\\",\\\"id\\\":\");");
        sb.AppendLine("  Serial.print(idx);");
        sb.AppendLine("  Serial.print(\",\\\"value\\\":\");");
        for (int i = 0; i < config.Inputs.Count; i++)
        {
            if (config.Inputs[i] is EncoderConfiguration)
            {
                sb.AppendLine($"  if (idx == {i}) Serial.print(encoderValue_{i});");
            }
        }
        sb.AppendLine("  Serial.println(\"}\");");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("void setDisplayValue(int idx, long value) {");
        for (int i = 0; i < config.Displays.Count; i++)
        {
            sb.AppendLine($"  if (idx == {i}) displayValue_{i} = value;");
        }
        sb.AppendLine("}");

        return sb.ToString();
    }

    public IReadOnlyList<ArduinoLibrary> GetRequiredLibraries(ProjectConfiguration config)
    {
        var libraries = new List<ArduinoLibrary>
        {
            new()
            {
                Name = "ArduinoJson",
                Version = "6.x",
                IncludeStatement = "#include <ArduinoJson.h>",
                Url = "https://github.com/bblanchon/ArduinoJson"
            }
        };

        if (config.Displays.Count > 0)
        {
            libraries.Add(new ArduinoLibrary
            {
                Name = "LedControl",
                Version = "1.0.6",
                IncludeStatement = "#include <LedControl.h>",
                Url = "https://github.com/wayoda/LedControl"
            });
        }

        if (config.Inputs.Any(i => i is EncoderConfiguration))
        {
            libraries.Add(new ArduinoLibrary
            {
                Name = "Encoder",
                Version = "1.4.2",
                IncludeStatement = "#include <Encoder.h>",
                Url = "https://github.com/PaulStoffregen/Encoder"
            });
        }

        return libraries;
    }

    public async Task SaveSketchAsync(GeneratedCode code, string folderPath)
    {
        var sketchFolder = Path.Combine(folderPath, code.SketchName);
        Directory.CreateDirectory(sketchFolder);

        var mainFile = Path.Combine(sketchFolder, $"{code.SketchName}.ino");
        await File.WriteAllTextAsync(mainFile, code.MainSketch);

        foreach (var header in code.HeaderFiles)
        {
            var headerFile = Path.Combine(sketchFolder, header.Key);
            await File.WriteAllTextAsync(headerFile, header.Value);
        }
    }

    public Task<CompilationResult> ValidateCompilationAsync(GeneratedCode code)
    {
        // This would require Arduino CLI to be installed
        // For now, return a placeholder result
        return Task.FromResult(new CompilationResult
        {
            Success = true,
            Warnings = ["Compilation validation requires Arduino CLI"]
        });
    }

    private static string SanitizeSketchName(string name)
    {
        var sanitized = new string(name.Where(c => char.IsLetterOrDigit(c) || c == '_').ToArray());
        if (string.IsNullOrEmpty(sanitized) || char.IsDigit(sanitized[0]))
        {
            sanitized = "Sketch_" + sanitized;
        }
        return sanitized;
    }

    private static string GetArduinoKeyCode(KeyboardKey key)
    {
        return key switch
        {
            >= KeyboardKey.A and <= KeyboardKey.Z => $"'{(char)('a' + (key - KeyboardKey.A))}'",
            >= KeyboardKey.Num0 and <= KeyboardKey.Num9 => $"'{(char)('0' + (key - KeyboardKey.Num0))}'",
            >= KeyboardKey.F1 and <= KeyboardKey.F12 => $"KEY_F{key - KeyboardKey.F1 + 1}",
            KeyboardKey.Enter => "KEY_RETURN",
            KeyboardKey.Escape => "KEY_ESC",
            KeyboardKey.Backspace => "KEY_BACKSPACE",
            KeyboardKey.Tab => "KEY_TAB",
            KeyboardKey.Space => "' '",
            KeyboardKey.UpArrow => "KEY_UP_ARROW",
            KeyboardKey.DownArrow => "KEY_DOWN_ARROW",
            KeyboardKey.LeftArrow => "KEY_LEFT_ARROW",
            KeyboardKey.RightArrow => "KEY_RIGHT_ARROW",
            KeyboardKey.Delete => "KEY_DELETE",
            KeyboardKey.Insert => "KEY_INSERT",
            KeyboardKey.Home => "KEY_HOME",
            KeyboardKey.End => "KEY_END",
            KeyboardKey.PageUp => "KEY_PAGE_UP",
            KeyboardKey.PageDown => "KEY_PAGE_DOWN",
            _ => $"'{key.ToString().ToLower()[0]}'"
        };
    }

    private static string GetArduinoModifiers(ModifierKeys modifiers)
    {
        var parts = new List<string>();

        if (modifiers.HasFlag(ModifierKeys.Ctrl))
            parts.Add("Keyboard.press(KEY_LEFT_CTRL);");
        if (modifiers.HasFlag(ModifierKeys.Shift))
            parts.Add("Keyboard.press(KEY_LEFT_SHIFT);");
        if (modifiers.HasFlag(ModifierKeys.Alt))
            parts.Add("Keyboard.press(KEY_LEFT_ALT);");
        if (modifiers.HasFlag(ModifierKeys.Gui))
            parts.Add("Keyboard.press(KEY_LEFT_GUI);");

        return string.Join(" ", parts);
    }

    private static string Indent(string code, int spaces = 2)
    {
        var indent = new string(' ', spaces);
        return string.Join(Environment.NewLine,
            code.Split(Environment.NewLine).Select(line => string.IsNullOrWhiteSpace(line) ? line : indent + line));
    }
}
